---
phase: 04-weekly-scorecard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/lib/actions.ts
  - src/lib/queries.ts
  - src/components/ui/toggle-group.tsx
  - src/components/ui/switch.tsx
  - src/components/ui/label.tsx
autonomous: true

must_haves:
  truths:
    - "Scorecard ratings can be upserted without duplicate row errors"
    - "scorecardNotes column exists on weekends table"
    - "saveRating and saveScorecardNotes Server Actions accept valid input and persist to database"
    - "getWeekendById returns scorecardRatings and scorecardNotes in its response"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "Unique constraint on scorecardRatings(weekendId, criterion) + scorecardNotes column on weekends"
      contains: "unique.*scorecard_ratings_weekend_criterion"
    - path: "src/lib/actions.ts"
      provides: "saveRating upsert and saveScorecardNotes Server Actions"
      exports: ["saveRating", "saveScorecardNotes"]
    - path: "src/lib/queries.ts"
      provides: "Updated getWeekendById with scorecardRatings relation"
      contains: "scorecardRatings"
    - path: "src/components/ui/toggle-group.tsx"
      provides: "shadcn/ui ToggleGroup component"
    - path: "src/components/ui/switch.tsx"
      provides: "shadcn/ui Switch component"
    - path: "src/components/ui/label.tsx"
      provides: "shadcn/ui Label component"
  key_links:
    - from: "src/lib/actions.ts"
      to: "src/db/schema.ts"
      via: "import scorecardRatings, weekends; onConflictDoUpdate uses unique constraint"
      pattern: "onConflictDoUpdate.*target.*weekendId.*criterion"
    - from: "src/lib/queries.ts"
      to: "src/db/schema.ts"
      via: "relational query includes scorecardRatings"
      pattern: "scorecardRatings:\\s*true"
---

<objective>
Add the data layer and UI primitives required for the weekly scorecard feature.

Purpose: Establish the schema changes (unique constraint for upserts + scorecardNotes column), Server Actions (saveRating, saveScorecardNotes), query update (include scorecardRatings), and install the shadcn/ui components (ToggleGroup, Switch, Label) that Plan 02 will compose into the scorecard UI.

Output: Modified schema pushed to Neon, two new Server Actions, updated query, and three new shadcn/ui components installed.
</objective>

<execution_context>
@/Users/vladimirtsoy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladimirtsoy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/db/schema.ts
@src/lib/actions.ts
@src/lib/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema changes and shadcn/ui component installation</name>
  <files>src/db/schema.ts, src/components/ui/toggle-group.tsx, src/components/ui/switch.tsx, src/components/ui/label.tsx</files>
  <action>
1. **Install shadcn/ui components** by running:
   ```bash
   npx shadcn@latest add toggle-group --yes
   npx shadcn@latest add switch --yes
   npx shadcn@latest add label --yes
   ```

2. **Modify `src/db/schema.ts`** -- two changes:

   a. Add `unique` to the import from `drizzle-orm/pg-core`:
   ```typescript
   import { pgTable, pgEnum, integer, varchar, text, boolean, timestamp, real, unique } from "drizzle-orm/pg-core";
   ```

   b. Add `scorecardNotes` column to the `weekends` table definition, after the existing `notes` column:
   ```typescript
   scorecardNotes: text("scorecard_notes"),
   ```

   c. Add a composite unique constraint to the `scorecardRatings` table using the third argument callback pattern:
   ```typescript
   export const scorecardRatings = pgTable("scorecard_ratings", {
     // ... existing columns stay the same ...
   }, (t) => [
     unique("scorecard_ratings_weekend_criterion").on(t.weekendId, t.criterion),
   ]);
   ```

3. **Push schema to Neon:**
   ```bash
   npx drizzle-kit push
   ```
   Accept the prompts to apply the unique constraint and new column.

**Important:** Do NOT change any existing column definitions. Only ADD the `scorecardNotes` column and the unique constraint callback.
  </action>
  <verify>
- `npx drizzle-kit push` completes without errors
- `src/db/schema.ts` contains `unique("scorecard_ratings_weekend_criterion")`
- `src/db/schema.ts` contains `scorecardNotes: text("scorecard_notes")`
- `src/components/ui/toggle-group.tsx`, `switch.tsx`, `label.tsx` exist
- `npm run build` has no type errors related to schema changes
  </verify>
  <done>
- Schema has composite unique constraint on scorecardRatings(weekendId, criterion)
- Weekends table has scorecardNotes text column
- ToggleGroup, Switch, and Label shadcn/ui components are installed
  </done>
</task>

<task type="auto">
  <name>Task 2: Server Actions and query update for scorecard</name>
  <files>src/lib/actions.ts, src/lib/queries.ts</files>
  <action>
1. **Add `saveRating` Server Action to `src/lib/actions.ts`:**

   Add the import for `scorecardRatings` to the existing schema import:
   ```typescript
   import { workItems, weekends, scorecardRatings } from "@/db/schema";
   ```

   Then add the action after the existing `saveNotes` function:

   ```typescript
   // --- Save Scorecard Rating ---

   const VALID_CRITERIA = ['outcome_quality', 'time_saved', 'repeatability', 'use_again'] as const;

   const saveRatingSchema = z.object({
     weekendId: z.number().int().positive(),
     criterion: z.enum(VALID_CRITERIA),
     rating: z.number().int().min(0).max(5),
   });

   export async function saveRating(weekendId: number, criterion: string, rating: number) {
     const parsed = saveRatingSchema.parse({ weekendId, criterion, rating });

     await db
       .insert(scorecardRatings)
       .values({
         weekendId: parsed.weekendId,
         criterion: parsed.criterion,
         rating: parsed.rating,
       })
       .onConflictDoUpdate({
         target: [scorecardRatings.weekendId, scorecardRatings.criterion],
         set: {
           rating: parsed.rating,
           updatedAt: new Date(),
         },
       });

     revalidatePath(`/weekend/${parsed.weekendId}`);
   }
   ```

2. **Add `saveScorecardNotes` Server Action to `src/lib/actions.ts`:**

   ```typescript
   // --- Save Scorecard Notes ---

   const saveScorecardNotesSchema = z.object({
     weekendId: z.number().int().positive(),
     notes: z.string().max(50000),
   });

   export async function saveScorecardNotes(weekendId: number, notes: string) {
     const parsed = saveScorecardNotesSchema.parse({ weekendId, notes });

     await db
       .update(weekends)
       .set({
         scorecardNotes: parsed.notes,
         updatedAt: new Date(),
       })
       .where(eq(weekends.id, parsed.weekendId));

     revalidatePath(`/weekend/${parsed.weekendId}`);
   }
   ```

3. **Update `getWeekendById` in `src/lib/queries.ts`** to include scorecardRatings:

   Add `scorecardRatings: true` to the `with` clause:
   ```typescript
   export async function getWeekendById(id: number) {
     return db.query.weekends.findFirst({
       where: eq(weekends.id, id),
       with: {
         workItems: {
           orderBy: (workItems, { asc }) => [asc(workItems.sortOrder)],
         },
         doneCriteria: {
           orderBy: (doneCriteria, { asc }) => [asc(doneCriteria.sortOrder)],
         },
         scorecardRatings: true,
       },
     });
   }
   ```

**Important:** The `saveRating` action uses `onConflictDoUpdate` which requires the unique constraint from Task 1. The `criterion` field is validated against a strict enum of the 4 valid values. The `rating` field uses `z.number().int()` to enforce integer values even though the DB column is `real`.
  </action>
  <verify>
- `npm run build` completes without type errors
- `src/lib/actions.ts` exports `saveRating` and `saveScorecardNotes`
- `src/lib/queries.ts` includes `scorecardRatings: true` in `getWeekendById`
- Grep for `onConflictDoUpdate` in actions.ts returns a match
  </verify>
  <done>
- saveRating Server Action upserts a scorecard rating for a given (weekendId, criterion) pair
- saveScorecardNotes Server Action updates the weekends.scorecardNotes column
- getWeekendById query returns scorecardRatings alongside workItems and doneCriteria
- All inputs are validated with zod schemas
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with zero type errors
2. Schema changes are pushed to Neon (unique constraint + scorecardNotes column)
3. Three shadcn/ui components installed (toggle-group, switch, label)
4. Two new Server Actions exported from actions.ts
5. Query layer updated to include scorecardRatings
</verification>

<success_criteria>
- The data layer for scorecard functionality is complete: schema supports upserts, Server Actions handle rating saves and notes saves, query returns all scorecard data
- UI primitives (ToggleGroup, Switch, Label) are installed and ready for composition in Plan 02
- Build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-weekly-scorecard/04-01-SUMMARY.md`
</output>
